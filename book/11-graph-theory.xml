<?xml version="1.0"  encoding="ISO-8859-1" ?> 
<!DOCTYPE sys-ents [ <!ENTITY bibliography SYSTEM "bibliography.xml"> ]> 
<?xml-stylesheet type="text/xsl" href="../book.xsl"?>


<document>
&bibliography;
<title>Graph Theory: The Mathematics of Networks</title>

<text>
Graph Theory is the mathematical study of graphs (or networks).
</text>

<text>
[idea] A graph as a mathematical representation of a system composed of interconnected elements. Applications: human interactions, transportation systems, communication networks, electronic circuits... They can be used to represent any kind of relationship.
</text>

<document>
<tag>graph-theory-fundamentals</tag>
<title>Graphs and their terminology</title>


<text>
From a formal point of view, a graph <eqn>G=(V,E)</eqn> is a finite non-empty set <eqn>V</eqn> of vertices (or nodes) together with a possibly empty set <eqn>E</eqn> of pairs of vertices called edges (also known as links). In other words, <eqn>V \neq \emptyset</eqn> and <eqn>E \subseteq V \times V</eqn>. A graph <eqn>G=(V,E)</eqn>, therefore, has a vertex set <eqn>V</eqn> and an edge set <eqn>E</eqn>, which are often denoted by <eqn>V(G)</eqn> and <eqn>E(G)</eqn>, respectively.
</text>

<text>
Nodes (vertices) correspond to the elements of the system represented by the graph, whereas links (edges) represent their connections. In a social network, for instance, people are represented as nodes while friendship relationships are represented by links between pairs of nodes. In practice, we will restrict ourselves to dyadic (pairwise) relationships when representing graphs.
</text>

<text>
Any member <eqn>e=(u,v)</eqn> of <eqn>E(G)</eqn> is an edge in <eqn>G</eqn> with end vertices <eqn>u</eqn> and <eqn>v</eqn>. Both <eqn>u</eqn> and <eqn>v</eqn> are incident with the edge <eqn>e</eqn>. 
</text>

<text>
A self-loop, or loop for short, is an edge <eqn>(v,v)</eqn> from one vertex <eqn>v</eqn> to itself.
</text>


<text>
When <eqn>(u,v)</eqn> is an edge in <eqn>G</eqn>, <eqn>u</eqn> and <eqn>v</eqn> are adjacent vertices and they are said to be neighbors of each other. Likewise, when both <eqn>(u,v)</eqn> and <eqn>(v,w)</eqn> are edges in <eqn>G</eqn>, they are said to be adjacent edges.
</text>

<text>
The number of vertices in the graph is the order of the graph, whereas the number of edges in the graph is the size of the graph. We will typically use <eqn>n</eqn> to denote the order of the graph (i.e. its number of nodes) and <eqn>m</eqn> to denote its size (i.e. its number of links).
</text>

<!--
{V \choose 2} the set of all pairs of its vertices. 
The graph \overline{G} = (V, {V \choose 2} \ E) is the complementary graph. 
Two vertices of V are adjacent in G if and only if they are not adjacent in \overline{G}

The line graph L(G) of a graph G has as vertices the edges of G; two edges
of G are adjacent in L(G) if and only if they have a common vertex in G. For
example, the line graph of the complete graph Kn is the triangular graph Tn
-->


<!-- Undirected / directed -->

<document>
<tag>graph-theory-directed</tag>
<title>Directed vs. undirected graphs</title>

<text>
In scenarios such as the social network mentioned above, where we consider friendship relationships to be symmetric, links will be undirected. In undirected graphs, therefore, edges are two-element subsets of <eqn>V(G)</eqn>. An edge <eqn>{u,v}</eqn> can then be denoted as <eqn>uv</eqn> or <eqn>vu</eqn>, since both are considered to be equivalent. In other words, both <eqn>(u,v)</eqn> and <eqn>(v,u)</eqn> belong to <eqn>E(G)</eqn> as defined above.
</text>


<text>
++ Directed graphs (= digraphs): undirected graphs for nondirectional links, directed graphs for directional links.

Examples: road networks (lanes in both directions) are undirected vs. street networks within cities (typically directed due to one-way streets; program flow graphs are typically directed (dependences)...
</text>

</document>


<!-- Weighted graphs -->

<document>
<tag>graph-theory-weighted</tag>
<title>Binary vs. weighted graphs</title>

<text>
++ Binary vs. weighted graphs: binary graphs for dichotomous links (ties are either present or absent for each pair of nodes), weighted graphs for valued links (that indicate the strength, intensity, or frequency of the tie between each pair of actors). Binary graphs, also known as unweighted graphs...

- Each edge is assigned a numerical value or weigth; e.g. road network (length, traversal time, construction cost, speed limit...)
</text>

</document>


<!-- Multigraphs -->

<document>
<tag>graph-theory-multi</tag>
<title>Multigraphs</title>

<text>
In multigraphs, there are pairs of vertices that are connected by more than one edge. An edge is said to be a multiedge when it appears more than once in the same graph (i.e. multigraph). 
</text>

<text>
In multigraphs, we replace the edge set of an ordinary graph (by a family <eqn>E</eqn> of two-element subsets of <eqn>V</eqn>. 
Formally, we define a multigraph as a triple <eqn>(V, E, J)</eqn> where <eqn>J</eqn> is a mapping from <eqn>E</eqn> to the set of two-element
subsets of <eqn>V</eqn>, so that we can distinguish different edges connecting the same pair of vertices. <eqn>J</eqn> is called the incidence map because the image <eqn>J(e)</eqn> of an edge <eqn>e</eqn> is the set <eqn>{u, v}</eqn> of the end vertices of <eqn>e</eqn>.
</text>

<text>
When <eqn>J(e) = J(e')</eqn>, we say that edges <eqn>e</eqn> and <eqn>e'</eqn> are parallel.
</text>

<text>
Multigraphs can be generalized if we allow loops, i.e. edges <eqn>e</eqn> whose <eqn>J(e)</eqn> is a singleton set <eqn>{v}</eqn>. In this case, multigraphs are often calledd pseudographs.
</text>

<text>
A graph without multiedges nor self-loops is called a simple graph. Multiedges and self-loops introduce some subtetlies in the design of graph algorithms, hence simple graphs are often preferred.
</text>

</document>

<!-- Labeled graphs -->

<document>
<tag>graph-theory-label</tag>
<title>Labeled graphs and attribute graphs</title>

<text>
++ Labeled graphs: Each vertex is assigned a name or identifier (may not be unique). Note: the index of a node within the graph is often employed as a surrogate for the node identifier (for convenience when implementing efficient algorithms and also for preserving anonymity in some applications).
</text>

<text>
++ Attribute graphs @ attributes at nodes and edges
</text>

</document>

</document>


<!-- Node degree -->

<document>
<tag>graph-theory-degree</tag>
<title>Node degree and degree sequences</title>

<text>
The set of neighbors of a vertex <eqn>v</eqn> is the neighborhood of <eqn>v</eqn> and is denoted by <eqn>N_G(v)</eqn>. Technically, this is the open neighborhood of the vertex (the closed neighborhood would also include the vertex <eqn>v</eqn> itself). 
</text>

<text>
The degree of a vertex <eqn>v</eqn> in a graph <eqn>G</eqn> is the number of vertices in <eqn>G</eqn> that are adjacent to <eqn>v</eqn>, i.e. the size of its neighborhood: <eqn>deg_G(v) = |N_G(v)|</eqn>.
</text>

<text>
Since every edge is counted twice (once for each one of its incident vertices), the sum of all vertex degrees is twice the size of the graph, i.e. <eqn>\sum deg_G(v) = 2|E(G)| = 2m</eqn>, a basic result known as the First Theorem of Graph Theory and also referred to as the Handshaking Lemma <cite>Chartrand et al. 2011</cite>. Since the sum of all vertex degrees is even, the number of vertices of odd degree must also be even. Moreover, the average degree of a graph <eqn>G</eqn> of order <eqn>n</eqn> and size <eqn>m</eqn> can be easily computed, since it is always <eqn>2m/n</eqn>.
</text>

<text>
The minimum degree among the vertices of G is denoted by <eqn>\delta(G)</eqn>, while the maximum degree in G is denoted by <eqn>\Delta(G)</eqn>. Hence, <eqn>0 \le \delta(G) \le deg_G(v) \le \Delta(G) \le n-1</eqn> for simple graphs.
</text>


<text>
++ Directed: in-degree, out-degree, full degree (in+out)
</text>

<text>
++ Weighted graphs: Node strength instead of node degree = Sum of all the edge weights of a node.
</text>



<document>
<tag>graph-theory-degree-sequence</tag>
<title>Degree sequences</title>

<text>
An integer partition p = (p_1, ..., p_n) where p_i is the degree of the ith highest-degree node in the graph.

p is an integer partition of 2m, i.e. sum p_i = 2m, in undirected graphs, since each edge contributes to the degree of two nodes.

Not all integer partitions correspond to actual graphs.

An algorithm to build a graph given a degree sequence: the highest-degree node is connected to the following node; the degree sequence is updated by decrementing p_1 and p_2 (and reorder the partition), resulting in a smaller partition; the process is repeated until the degree sequence is full of zeroes (or a negative value appears, which means the graph was not realizable).

The algorithm above is deterministic. If we want a random graphs with the given degree sequence, we can generate them by flipping edges: from (x,y) and (w,z) we create (x,w) and (y,z), which yields a different graph with the same degree sequence (albeit it should be noted that the resulting graph is not necessarily connected).
</text>

</document>

</document>


<!-- Graph connectivity -->

<document>
<tag>graph-theory-connectivity</tag>
<title>Connectivity, paths, and distance</title>


<text>
Graphs are sparse when existing edges represent a small fraction of the possible vertex pairs. They are dense when there are edges between most vertex pairs. Dense graphs typically have a quadratic number of edges, whereas sparse graphs are linear in size. The application domain often imposes limits of the number of edges that are incident on any given node within the graph, hence most real-world graphs are actually sparse.
</text>


<document>
<tag>graph-theory-paths</tag>
<title>Paths and cycles</title>

<!-- Walks, trails, and paths -->

<text>
A walk is a sequence of adjacent edges in a graph. Formally, a sequence of edges <eqn>(e_1, ..., e_n)</eqn> is a walk is there are vertices <eqn>v_0, ..., v_n</eqn> such that <eqn>e_i = v_{i-1}v{i}</eqn> for <eqn>i = 1..n</eqn>. For the sake of simplicity, we can specify a walk by its sequence of vertices <eqn>(v0, ..., vn)</eqn>, provided that <eqn>v_{i-1}v_i</eqn> is an edge in the graph for <eqn>i = 1..n</eqn>. Given a walk <eqn>(v0, ..., vn)</eqn>, <eqn>v_0</eqn> is said to be its start vertex, <eqn>v_n</eqn> is its end vertex, and <eqn>n</eqn> is its length. When the start vertex and the end vertex are the same, i.e. <eqn>v_0 = v_n</eqn>, the walk is said to be a closed walk. 
</text>

<text>
When all the edges in a walk are distinct, the walk is called a trail. Consequently, a closed walk without repeating edges is a closed trail.
</text>

<text>
When, both edges and nodes are distinct, the trail becomes a path. It should be noted that any walk always contains a path from its start vertex to its end vertex (plus some optional detours). 
</text>

<!-- Cycles -->

<text>
A cycle (or circuit) is a closed trail with <eqn>n \geq 3</eqn> and distinct nodes (except, of course, <eqn>v_0 = v_n</eqn>). Any closed walk of
odd length necessarily contains a cycle, whereas some closed walks of even length do not contain cycles (e.g. jumping from the starting node to one of its neighbors and returning back to it). 
</text>

<text>
A cycle of length three is called a triangle.  ++transitive relationships
</text>

<text>
Acyclic graphs do not contain any cycles. ++ important classes: DAGs, trees
</text>
 
 

<document>
<tag>graph-theory-eulerian</tag>
<title>Eulerian circuits</title>

<text>
The Königsberg bridge problem studied by Euler in 1736, which originated the study of graph theory, asked for a circular tour containing every edge in the graph (a multigraph in the Königsberg brige problem, actually, since it contained two pairs of parallel edges). Such circular tours, which traverse every edge in the graph, are called Eulerian circuits.
</text>

<text>
Formally, an Eulerian trail of <eqn>G</eqn> is a trail that contains every edge in <eqn>G</eqn> exactly once. When the trail is closed, it is an Euler tour. A graph is Eulerian when it contains an Euler tour. The terms Eulerian cycle and Eulerian circuit are often used instead of Euler tour, even though an Euler tour can include the same vertices more than once. Likewise, the term Eulerian path is usually employed to refer to Eulerian trails.
</text>

<text>
Euler's theorem characterizes Eulerian graphs <cite>Euler 1736</cite>. Given a connected graph <eqn>G</eqn>, Euler's theorem establishes that the following statements are equivalent:
</text>

<list>
<item>G is Eulerian.</item>
<item>Each vertex in G has even degree.</item>
<item>The edge set of G can be partitioned into cycles.</item>
</list>

<text>
Since Euler tours must traverse all the edges in a graph and each occurrence of a vertex in the Euler tour adds two to its degree, it follows that all vertices must have an even degree. This result proves that the Königsberg bridge problem has no solution, since all the vertices in its associated graph have odd degrees.
</text>

<text>
I can also be proved that, given a connected graph with exactly <eqn>2k</eqn> vertices of odd degree, with <eqn>k \neq 0</eqn>, the edge set of the graph can be partitioned into <eqn>k</eqn> trails. Taking this into account, it is easy to obtain the following results:
</text>

<list>

<item>
An undirected graph contains an Eulerian circuit iff (1) it is connected, and (2) each vertex is of even degree.
</item>

<item>
An undirected graph contains an Eulerian path iff (1) it is connected, and (2) all but two vertices are of even degree. These two vertices will be the start and end points of any Eulerian path.
</item>

</list>

<text>
Similar results can be derived for directed graphs:
</text>

<list>

<item>
A directed graph contains an Eulerian cycle iff (1) it is strongly-connected, and (2) each vertex has the same in-degree as out-degree.
</item>

<item>
A directed graph contains an Eulerian path from x to y iff (1) it is connected, and (2) all other vertices have the same in-degree as out-degree,
with x and y being vertices with in-degree one less and one more than their out-degrees, respectively.
</item>

</list>

<!-- The line graph of an Eulerian graph is likewise Eulerian, butt the converse is false in general. -->

</document>


<document>
<tag>graph-theory-hamiltonian</tag>
<title>Hamiltonian circuits</title>

<text>
Hamiltonian circuits are somehow related to Euler tours. Whereas every edge is traversed by an Euler tour, Hamiltonian cycles require visiting each node in the graph exactly once.
</text>

<text>
Formally, a Hamiltonian path or traceable path is a path that visits every vertex exactly once. A graph that contains a Hamiltonian path is called a traceable graph. A graph is said to be Hamiltonian-connected if, for every pair of vertices, there is a Hamiltonian path between them. A Hamiltonian cycle, Hamiltonian circuit, vertex tour, or graph cycle is a circuit that visits each vertex exactly once (except the vertex that is both the start and end, which is visited twice). Finally, a graph that contains a Hamiltonian cycle is called a Hamiltonian graph.
</text>

<!-- Any Hamiltonian cycle can be converted to a Hamiltonian path by removing one of its edges, 
but a Hamiltonian path can be extended to Hamiltonian cycle only if its endpoints are adjacent. -->


<text>
Although Euler tours and Hamiltonian circuit look similar, they are quite different problems. While it is easy to find an Euler tour, it is hard to find a Hamiltonian circuit. In fact, there is no nice characterization of Hamiltonian graphs.
</text>

<text>
We know, for instance, that some kinds of graphs are Hamiltonian, including complete graphs <eqn>K_n</eqn> with more than two vertices, every cycle graph, every tournament, and every platonic solid. We also know some sufficient conditions for the existence of a Hamiltonian cycle, usually in the form of statements about the degrees of the vertices in the graph:
</text>

<list>

<item>A graph with more than two vertices is Hamiltonian if every vertex in the graph has degree <eqn>\geq n/2</eqn> (Dirac's theorem, 1952).</item>

<item>A graph with more than two vertices is Hamiltonian if, for every pair of non-adjacent vertices, the sum of their degrees is n or greater (Ore's theorem, 1960).</item>

<item>A graph <eqn>G</eqn> is Hamiltonian if and only if its closure <eqn>[G]</eqn> is Hamiltonian (Bondy–Chvátal theorem, 1972).</item>

</list>

<text>
Given a graph <eqn>G</eqn> defined on <eqn>n</eqn> vertices, its closure <eqn>[G]</eqn> is constructed by successively adding edges <eqn>uv</eqn> to <eqn>G</eqn> for all nonadjacent pairs of vertices <eqn>u</eqn> and <eqn>v</eqn> that satisfy the following condition: <eqn>deg_G(v) + deg_G(u) \geq n</eqn>. In the closure of <eqn>G</eqn>, therefore, for any two non-adjacent vertices <eqn>u</eqn> and <eqn>v</eqn>, we always have <eqn>deg_G(u) + deg_G(v) &lt; n</eqn>.
</text>

<text>
Since complete graphs are Hamiltonian, all graphs whose closure is complete will also be Hamiltonian. This result subsumes Dirac's and Ore's theorems, hence showing that the Bondy-Chvátal theorem theorem generalizes the previous two ones.
</text>

<text>
Similar characterizations can be obtained for directed graphs:
</text>

<list>

<item>
A strongly connected simple directed graph with n vertices is Hamiltonian or some vertex has a full degree smaller than n (Ghouila-Houiri theorem, 1960).
</item>

<item>
A strongly connected simple directed graph with n vertices is Hamiltonian or the sum of the full degrees of any two distinct non-adjacent vertices is smaller than <eqn>2n-1</eqn> (Meyniel's theorem, 1973).
</item>

</list>

<text>
The number of vertices in these sufficient conditions is doubled with respect to the undirected case because each undirected edge corresponds to two directed arcs and the full degree of a vertex in the directed graph is twice its degree in the undirected graph.
</text>

<!-- The line graph of an Eulerian graph is Hamiltonian: If G is Eulerian, then L(G) is Hamiltonian -->
<!-- The line graph of a Hamiltonian graph is Hamiltonian. -->
<!-- A tournament (with more than 2 vertices) is Hamiltonian if and only if it is strongly connected. -->


<text>
It should be noted that the number of different Hamiltonian cycles in a complete undirected graph on <eqn>n</eqn> vertices is <eqn>(n-1)!/2</eqn>, <eqn>(n-1)!</eqn> in a complete directed graph. Many important problems can be stated as finding the optimal Hamiltonian cycle in some sense and, since no general efficient method is known for finding one, their resolution requires the use of combinatorial optimization techniques. The traveling salesman problem (TSP) is probably the most famous of such problems: planning the minimum cost route for a traveling salesman who must visit <eqn>n</eqn> cities, where cost is typically associated to the traveled distance, even though other optimization criteria could be used (e.g. the time it takes to complete the tour or its actual monetary cost, which might depend on many other factors beyond time and distance). From a formal point of view, the solution to the TSP involves finding the cyclic permutation <eqn>\pi</eqn> of the graph vertex set that minimizes the cost function. Just enumerating the potential solutions is prohibitive in practice, since there are <eqn>(n-1)!</eqn> of them. Actually, there are <eqn>n!</eqn> permutations, but we can always set the starting node of the circuit, hence the <eqn>n</eqn> factor we can save.
</text>


</document>

</document>


<document>
<tag>graph-theory-components</tag>
<title>Connected components</title>

<text>
++ Connected graphs, weakly-connected vs. strongly-connected components (a.k.a. blocks)

A graph G is strongly connected if all nodes in G can reach v and are reachable from v.

Weakly-connected and strongly-connected components define unique partitions of the graph nodes.
</text>

<text>

J:
Two vertices a and b of a graph G are connected if there exists a walk
with start vertex a and end vertex b. If all pairs of vertices of G are connected,
G itself is called connected. 

For any vertex a, we consider (a) as a trivial walk
of length 0, so that any vertex is connected with itself. Thus connectedness
is an equivalence relation on the vertex set of G. 

The equivalence classes of this relation are called the connected components of G. Thus G is connected if
and only if its vertex set V is its unique connected component.

Components which contain only one vertex are also called isolated vertices. 

- A graph with n vertices and assume that each vertex of G has degree at least (n-1)/2: G must be connected.
- A graph G is connected if and only if there exists an edge e = vw with v in V1 and w in V2 whenever V = V1 U V2 is a decomposition of the vertex set of G.(that is, V1 intersect V2 = empty)

<!--  If G is not connected, the complementary graph G is connected. -->

RESULTS
- A connected graph on n vertices has at least n-1 edges.
- An acyclic graph on n vertices has at most n-1 edges.
</text>

</document>



<document>
<tag>graph-theory-distance</tag>
<title>Distance</title>

<!-- Length / strength / distance -->

<text>
The number of edges in a walk, trail, path, or cycle (i.e. <eqn>n</eqn>) defines its length given the above formal specification, albeit we can relax this definition for weighted graphs. Whereas path lengths correspond to the number of edges paths contain in binary graphs, they can be computed using edge weights in weighted graphs. We will assume that paths composed of stronger edges span shorter lengths and, therefore, that the strength of the edge between two adjacent nodes is inversely proportional to the distance between them.
</text>


<text>
++ Distance, geodesic, eccentricity, diameter, radius


If a and b are two vertices in the same connected component of a graph G, there has to exist a path of shortest length (say d) between a and b. (Why?)
Then a and b are said to have distance d = d(a, b) ++ Junig. Chapter 3


The eccentricity of vertex v in a graph is the shortest-path distance to the farthest vertex from v. 
The radius of a graph is the smallest eccentricity of any vertex.
The diameter of a graph is the maximum eccentricity of any vertex.
The center is the set of vertices whose eccentricity is the radius.

</text>

<text>
An edge linking two nodes indicates that they can communicate directly, whereas longer paths are likely to have a lower effect on the network behavior.
</text>

<text>
++ Counting the number of paths of length k by matrix multiplication: A^k (includes non-simple paths), e.g. divide-and-conquer algorithm @ Skiena 425 [Karatsuba KO63], fast multiplication algorithms @ Skiena 403 [Strassen 69][Coppersmith 90][CKSU05]
</text>

<text>
The pairwise distance of the shortest path linking the nodes in a network is represented in its distance matrix. Its global maximum is the network diameter. The distance matrix describes the communication pattern within the network.
</text>

</document>


</document>


<!-- Classes -->

<document>
<tag>graph-theory-classes</tag>
<title>Interesting classes of graphs</title>

<text>
In a complete graph, every two distinct edges are adjacent, i.e. the size of a complete graph of order n is n(n-1)/2. The complete graph of order n is denoted by <eqn>K_n</eqn>. ++ tournament (orientation of a complete graph)
</text>


<document>
<tag>graph-theory-regular</tag>
<title>Regular graphs</title>

<text>
When all the nodes in a graph have the same degree (say r), the graph is a regular graph,
more precisely an r-regular graph. 
</text>


<document>
<title>Complete graphs</title>

<text>
The complete graph Kn has n vertices (that is, |V | = n) and all two-element subsets of V as edges. The graph <eqn>K_n</eqn> is <eqn>(n-1)</eqn>-regular and its size is <eqn>n(n-1)/2</eqn>.
</text>

<figure>
  <tag>fig-k5</tag>
  <image scale="25" file="image/graphs/k5"/>
  <title>The complete graph <eqn>K_5</eqn>.</title>
</figure>

</document>


<document>
<title>Cubic graphs</title>

A cubic graph is a graph in which all vertices have degree three, i.e. a 3-regular graph. Cubic graphs are also called trivalent graphs.

There are many well-known individual cubic graphs, including the utility graph (<eqn>K_{3,3}</eqn>), the Petersen graph, the Heawood graph, the Möbius-Kantor graph, the Pappus graph, the Desargues graph, the Nauru graph, the Coxeter graph, the Tutte-Coxeter graph (a.k.a. Tutte eight-cage), the Dyck graph, the Foster graph, or the Biggs-Smith graph.

For instance, the Petersen graph is an undirected small graph, with 10 vertices and 15 edges, which is often employed as an useful example or counterexample for many problems in graph theory.

<figure>
  <tag>fig-petersen</tag>
  <image scale="30" file="image/graphs/petersen"/>
  <title>The Petersen graph, a typical example of cubic graph.</title>
</figure>

</document>

<!--
<document>
<title>Triangular graphs</title>

J: he triangular graph Tn has as vertices the two-element subsets of a set with n elements. Two of these vertices are adjacent if and only if their intersection is not empty. Obviously, Tn is a (2n-4)-regular graph. 

Tn has even stronger regularity properties: the number of vertices adjacent to two given vertices x, y depends only on whether x and y
themselves are adjacent or not. Such a graph is called a strongly regular graph, abbreviated by SRG.

SRG: Tn has parameters a = 2n - 4, c = n - 2 and d = 4, where a is the degree of any vertex, c is the number of vertices adjacent to both x and y if x and y are adjacent, and d is the number of vertices adjacent to x and y if x and y are not adjacent. Let G be an SRG with parameters a, c, and d having n vertices. Its complementary graph \overline{G} is also an SRG. 

Theorem: a(a - c - 1) = (n - a - 1)d.

</document>
-->


</document>



<document>
<title>Grids</title>

<figure>
  <tag>fig-grid</tag>
  <image scale="30" file="image/graphs/grid"/>
  <title>A simple 5x4 2D grid.</title>
</figure>

</document>



<document>
<tag>graph-theory-bipartite</tag>
<title>Bipartite graphs</title>

<text>
++ Bipartite graphs

The complete bipartite graph Km,n has as vertex set the disjoint union of a set V1 with m elements and a set V2 with n elements; edges are all the
sets {a, b} with a in V1 and b in V2. 

The graph Km,n is regular only if m = n (in that case, it is n-regular). 

The utility graph, also known as the Thomsen graph or K_{3,3}: cubic (3-regular), nonplanar graph.
W: Two important characterizations of planar graphs, Kuratowski's theorem that the planar graphs are exactly the graphs that contain neither K3,3 nor the complete graph K5 as a subdivision, and Wagner's theorem that the planar graphs are exactly the graphs that contain neither K3,3 nor K5 as a minor, encompass this result.

</text>

<figure>
  <tag>fig-k33</tag>
  <image scale="30" file="image/graphs/k33"/>
  <image scale="20" file="image/graphs/k33pos"/>
  <title>Two different renderings of the complete bipartite graph <eqn>K_{3,3}</eqn>.</title>
</figure>


</document>


<document>
<tag>graph-theory-trees</tag>
<title>Trees</title>

<text>
++ Properties: connected, acyclic graphs

connected graph with n-1 edges and n nodes

DEFINITION

Let G be a graph with n vertices. Then any two of the following conditions imply the third:
(a) G is connected.
(b) G is acyclic.
(c) G has n - 1 edges.
graph T for which the conditions of Theorem 1.2.8 hold is called a tree.
A vertex of T with degree 1 is called a leaf.  ++ Juningkel Chapter 4.
</text>

<text>
Let (d1, . . . , dn) be a sequence of positive integers. Show
that there is a tree on n vertices having degrees d1, . . . , dn if and only if
d1 + . . . + dn = 2(n - 1),
</text>

<text>
A forest is a graph whose connected components are trees.
</text>


<text>
Trees are recursive structures, since cutting any edge leaves two smaller trees.
</text>


<text>
++ Rooted vs. free:

- Rooted trees define a hierarchical order, emanating from a single source node
identified as the root.
- Free trees do not encode any structure beyond their connection topology.
</text>

<text>
++ Special trees: stars, double stars, and caterpillars (spine)
</text>

<figure>
  <tag>fig-trees</tag>
  <image scale="20" file="image/graphs/star"/>
  <image scale="35" file="image/graphs/double-star"/>
  <image scale="50" file="image/graphs/caterpillar"/>
  <title>Special kinds of trees: stars, double stars, and caterpillars (or spines)</title>
</figure>


<text>
By f(n, s) we denote the number of forests G having n vertices and exactly s connected components,
for which s fixed vertices are in distinct components; in particular, the number
of trees on n vertices is f(n, 1). Cayley's theorem gives a formula for the numbers f(n, s)
</text>

<equation>
f(n, s) = sn^{n-s-1}
</equation>

<document>
<title>Prüfer codes</title>

<text>
As a corollary, we can conclude that the number of trees on <eqn>n</eqn> vertices is <eqn>n^{n-2}</eqn>, which is also the cardinality of the set of
words of length <eqn>n-2</eqn> over an alphabet with <eqn>n</eqn> elements. We can then specify a bijection between both sets: the set of trees with <eqn>n</eqn> nodes and the set of words of length <eqn>n-2</eqn> over <eqn>n</eqn> symbols. The Prüfer code is such a bijection and it allows us to represent trees as strings of <eqn>n-2</eqn> integers.
</text>


<text>
++ Prüfer codes (parents) [Prü 1918]

J: As we will need an ordering of the elements of V , we assume in what follows, without loss of generality, that V is a subset of N.
Thus let G = (V,E) be a tree. 

For n = 2 the only tree on V is mapped to the empty word; that is, we put \pi_V (G) = (). For n \geq 3 we use the smallest leaf of G to construct a tree on n-1 vertices. We write v = v(G) = min{u \in V : deg_G(u) = 1} and denote by e = e(G) the unique edge incident with v, and by w = w(G)
the other end vertex of e.

Now let G' = G \ v. Then G' has n-1 vertices, and we may assume by induction that we know the word corresponding to G'
under the Prüfer code on V' = V \ {v}. Hence we can define recursively \pi_V (G) = (w, \pi_{V'} (G'))

It remains to show that we have indeed constructed the desired bijection. We need the following lemma which allows us to determine the minimal leaf of a tree G on V from its Prüfer code: 

Let G be a tree on V . Then the leaves of G are precisely those elements of V which do not occur in \pi_V (G). In particular,
v(G) = min{u \in V : u does not occur in \pi_V (G)}.
</text>

<text>
EXAMPLES: shows some trees and their Prüfer codes for n = 6, one for each isomorphism class <cite>Jungnickel 2007</cite>,
- (1 (2 (3 (4 (5 (6)))))) = (2,3,4,5)
- (1 (2 (3 (4 (5 6))))) = (2,3,4,4)
- (1 (2 (3 (4 5 6)))) = (2,3,3,3)
- (1 (2 (3 (4)) (5 (6)) )) = (2,3,2,5)
- (1 (2 (3 4 (5 6)))) = (2,2,4,4)
- (1 (2 3 4 5 6) = (1,1,1,1)
</text>

<figure>
  <tag>fig-trees</tag>
  <image scale="80" file="image/graphs/trees"/>
  <title>Trees with six nodes.</title>
</figure>

<text>
+ The degree of a node is one more than the number of times its value appears in the Prüfer sequence
</text>

<text>
a simple way to rank and unrank labeled trees and solve any tree generation problem: Exactly n^(n-2) labeled trees on n vertices, which correspond to that many strings of length n-2 on the alphabet {1..n}.

NOTE: There are two models for generating data such as permutations: ranking/unranking (biyective function) and incremental change methods (iterators). Ranking/unranking methods make it trivial to generate random data (just generate a random number and rank), whereas enumeration by incremental change methods makes it tricky to generate random data (e.g. needed to solve some hard problems using randomized algorithms)

e.g. permutations [Knuth05a]

INCORRECT (does not generate permutations uniformly!) 

for i=1..n 
  a[i] = i

for j=1..n-1
  swap( a[i], a[random(1,n)]

CORRECT VERSION

for i=1..n 
  a[i] = i

for j=1..n-1
  swap( a[i], a[random(i,n)]

</text>

</document>

<document>
<title>Spanning trees</title>

<text>
++ Spanning trees: Matrix-Tree Theorem

The matrix tree theorem, also called Kirchhoff's matrix-tree theorem, states that the number of nonidentical spanning trees of a graph G is equal to any cofactor of the degree matrix of G  minus the adjacency matrix of G.
</text>

</document>

</document>



<document>
<tag>graph-theory-dag</tag>
<title>Directed acyclic graphs</title>

<text>
++ Directed acyclic graphs (DAGs), a.k.a. partial orders or posets, arise in some applications, e.g. scheduling
+ Topological sorting orders the vertices of a DAG respecting the precedence constraints imposed by the arcs in the DAG.
</text>

</document>



<document>
<title>Planar graphs</title>

<text>
Planar graphs, i.e. those that can be drawn on a plane without link crossings, are common in many applications. They are always sparse, since they have at most <eqn>2n-6</eqn> links. Trees, for instance, are also planar graphs.
</text>

</document>


</document>


<document>
<tag>graph-theory-isomorphism</tag>
<title>Isomorphic graphs and subgraphs</title>


<text>
Let <eqn>G=(V,E)</eqn> be a graph and <eqn>V'</eqn> be a subset of <eqn>V</eqn>. Using the notation in <cite>Jungnickel 2007</cite>, by <eqn>E|V'</eqn> we denote the set of all edges <eqn>e \in E(G)</eqn> that have both vertices in <eqn>V'</eqn>. The resulting graph <eqn>G'=(V',E|V')</eqn> is the induced subgraph of <eqn>G</eqn> on <eqn>V'</eqn> and it will be denoted as <eqn>G|V'</eqn>.
</text>

<!--
For a subset T of the vertex set V of a graph G we denote by G\ T the induced subgraph on V \ T. This graph arises from G by omitting all vertices in T and all edges incident with these vertices. For a one-element set T = {v} we write G \ v instead of G \ {v}. 
--> 

<text>
Each graph of the form <eqn>(V',E')</eqn> where <eqn>V' \subset V</eqn> and <eqn>E' \subseteq E|V'</eqn> is said to be a subgraph of <eqn>G</eqn>.
</text>

<text>
A subgraph of the same order of the original graph, i.e. when <eqn>V'=V</eqn>, is a spanning subgraph. 
</text>

<text>
A k-factor is a k-regular spanning subgraph. When the edge set of a graph is divided into k-factors, such a decomposition is called a k-factorization of the graph. A 1-factorization, or factorization for short, can exist only if <eqn>G</eqn> has an even number of vertices and it is also called a resolution. Factorizations of <eqn>K_{2n}</eqn> can be interpreted as schedules for tournaments of <eqn>2n</eqn> teams and always exist <cite>Jungnickel 2007</cite>.
</text>

<!-- Paths and cycles as subgraphs --> 

<text>
Paths and cycles are important kinds of subgraphs. A path <eqn>P_n</eqn> is a graph of order n and size n-1 whose vertices can be labeled <eqn>v_1, v_2, ..., v_n</eqn> and whose edges are <eqn>v_iv_{i+1}</eqn> for <eqn>i=1,2,...,n-1</eqn>. A cycle <eqn>C_n</eqn> is a graph of order n and size n whose whose vertices can be labeled <eqn>v_1, v_2, ..., v_n</eqn> and whose edges are <eqn>v_1v_n</eqn> and <eqn>v_iv_{i+1}</eqn> for <eqn>i=1,2,...,n-1</eqn>. The cycle <eqn>C_3</eqn> is called a triangle.
</text>

</document>


<document>
<tag>graph-theory-independent-paths</tag>
<title>Independent paths and cut sets</title>

<text>
++ Nonseparable graphs: cut-vertices (nodes) and blocks/branches => vertex-cuts (vertex-connectivity), bridges (edges) => edge-cuts (edge-connectivity)
</text>

<text>
++ Connectivity: k-connected &amp; k-edge-connected graphs
</text>

<text>
Whitney 1932
</text>

<equation>
\kappa(G) \le \lambda(G) \le \delta(G)
</equation>

<text>
Menger's theorem (Menger 1927)
</text>

<text>
Whitney's theorem (Whitney 1932)
</text>

</document>


<document>
<tag>graph-theory-laplacian</tag>
<title>Appendix: The graph Laplacian</title>
</document>


<document>
<tag>graph-theory-notes</tag>
<title>Bibliographic notes</title>

<text>
Origin of graph theory: Euler founded the field he called <q>geometria situs</q> (geometry of position), what is now known as graph theory.
</text>

<text>
Euler 1736 @ Könisberg Bridges == Eulerian circuits and Eulerian trails.
</text>

<text>
<q>In addition to that branch of geometry which is concerned with magnitudes, and
which has always received the greatest attention, there is another branch, pre-
viously almost unknown, which Leibniz first mentioned, calling it the geometry
of position. This branch is concerned only with the determination of position
and its properties; it does not involve measurements, nor calculations made
with them. It has not yet been satisfactorily determined what kind of problems
are relevant to this geometry of position, or what methods should be used in
solving them. Hence, when a problem was recently mentioned, which seemed
geometrical but was so constructed that it did not require the measurement of
distances, nor did calculation help at all, I had no doubt that it was concerned
with the geometry of position - especially as its solution involved only position,
and no calculation was of any use...</q> translated from <q>Solution of a problem relating to the geometry of position</q> <cite>Euler 1736</cite>
</text>

<text>
[Wikipedia] In 1736 Euler solved, or rather proved unsolvable, a problem known as the seven bridges of Königsberg. The city of Königsberg, Kingdom of Prussia (now Kaliningrad, Russia) is set on the Pregel River, and included two large islands which were connected to each other and the mainland by seven bridges. The question is whether it is possible to walk with a route that crosses each bridge exactly once, and return to the starting point. Euler's solution of the Königsberg bridge problem is considered to be the first theorem of graph theory. In addition, his recognition that the key information was the number of bridges and the list of their endpoints (rather than their exact positions) presaged the development of topology <cite>Alexanderson 2006</cite>.
This stamp of the former German Democratic Republic honoring Euler displaying his formula relating the number of faces, edges and vertices of a convex polyhedron. Euler also made contributions to the understanding of planar graphs. He introduced a formula governing the relationship between the number of edges, vertices, and faces of a convex polyhedron. Given such a polyhedron, the alternating sum of vertices, edges and faces equals a constant: V-E+F=2.
</text>


<text>
++ William Rowan Hamilton's Icosian Game @ 1856: Hamiltonian circuits. 

"Hamiltonian cycles apparently first arose in Euler's study of the knight's tour problem, although they were popularized by Hamilton's “Around the World” game in 1839."
</text>

<text>
Two 19th Century examples: Kirchhoff 1847 work on electrical networks (the foundation of circuit theory in electrical engineering) and Cayley 1857 use of trees to count alkanes (chemical compounds) = enumerating chemical isomers, molecules that contain the same number of atoms bonded in different ways.
</text>

<text>
The term graph was not used in its current sense until 1878, when J.J. Sylvester used it instead of <q>linkage</q>, which was the term used to refer to graphs at that time <cite>Gross and Yellen 2003</cite>.
</text>

<text>
First two books on graph theory: <cite>Konig 1936</cite> in German (English translation: <cite>Konig 1990</cite>) and <cite>Berge 1958</cite> in French (English translation: <cite>Berge 2001</cite>).
</text>

<text>
The first major book on graph theory written in English: <cite>Ore 1962</cite>.
</text>

<text>
The only other major book on graph theory published in English before 1970: <cite>Harary 1969</cite>
</text>

<text>
A retrospective from one of the key players in the development of graph theory: <cite>Tutte 1998</cite>
</text>

<text>
++ Other textbooks: <cite>Bondy and Murty 1976</cite> 
</text>

<text>
++ Modern textbooks, e.g. <cite>Chartrand et al. 2011</cite> <cite>Jungnickel 2007</cite> <cite>Diestel 2005</cite> <cite>Gross and Yellen 2005</cite> <cite>Gross and Yellen 2003</cite> <cite>Bollobas 2002</cite>. 
</text>

<text>
[note] Pure mathematics, not always with practical applications.
</text>

<text>
++ Introductory divulgative books, e.g. <cite>Chartrand 1984</cite>
</text>


</document>

</document>
