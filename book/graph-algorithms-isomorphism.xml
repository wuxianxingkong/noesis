<?xml version="1.0"  encoding="ISO-8859-1" ?> 
<!DOCTYPE sys-ents [ 
  <!ENTITY bibliography   SYSTEM "bibliography.xml">
]> 
<?xml-stylesheet type="text/xsl" href="../book.xsl"?>

<!-- Graph isomorphism -->

<document>
&bibliography;
<tag>graph-isomorphism</tag>
<title>Graph isomorphism</title>


<text>
Two graphs are said to be isomorphic if they are identical from a structural point of view. 

Graph isomorphism is, therefore, a formal vertex-to-vertex and edge-to-edge correspondence...
= adjacency-preserving bijection
</text>

<text>
"We need some terminology to settle what is meant when we say two graphs
are the same. Two labeled graphs G = (Vg,Eg) and H = (Vh,Eh) are identical
when (x, y) in Eg iff (x, y) in Eh. The isomorphism problem consists of finding a
mapping from the vertices of G to H such that they are identical. Such a mapping
is called an isomorphism; the problem of finding the mapping is sometimes called
graph matching."

+ Labeled graphs (unlabeled nodes can be considered to have a special label)
</text>



<text>
PROBLEM: Find a (or all) mapping f from the vertices of G to the vertices of H such that G and H are identical; i.e. (x, y) is an edge of G iff (f(x), f(y)) is an edge of H.
</text>

<text>
Considering all possible bijections between the vertices of two n-vertex graphs would require O(n!) checks. Fortunately, some heuristics are known...
</text>

<text>
Problem not known to be NP-complete, nor to be polynomial. According to Ladner's theorem [Lad75], if <eqn>P \neq NP</eqn>, then the intermediate complexity class NPI=NP-P is not empty and graph isomorphism a prime candidate for this category of problems.
<cite>Garey and Johnson 1979</cite>

ref. [Lad75]
R.E. Ladner: On the structure of polynomial time reducibility. JACM 22:155-171, 1975
</text>

<note>
<title>Automorphisms</title>

<text>
"A mapping of a graph to itself is called an automorphism. For example, the complete graph Kn has n! automorphisms
(any mapping will do), while an arbitrary random graph is likely to have few or perhaps only one, since G is always identical to itself"

i.e. notion of symmetry in graphs

- Orbit of a vertex u: set of vertices v such that there is an automorphism such that phi(u)=v
- Orbit of an edge d: set of edges e such that there is an automotphism such that phi(d)=e

- A graph is vertex transitive if all the vertices are in the same orbit
- A graph is edge transitive if all the edges are in the same orbit

- Vertex orbits partition the set of vertices in a graph
- Edge orbits partition the set of edges in a graph
</text>
</note>

<text>
APPLICATIONS
e.g. 

- Pattern matching: The structure of chemical compounds are naturally described
by labeled graphs, with each atom represented by a vertex. Identifying all
molecules in a structure database containing a particular functional group is an
instance of subgraph isomorphism testing.

- Identifying symmetries (automorphism)

- indexing graph databases by small substructures (and doing expensive isomorphism
tests only against those containing the same substructures as the query graph).
</text>

<text>
@ MIT Interactive proofs and zero knowledge
</text>


<text>
VARIATIONS

- "Subgraph isomorphism asks whether there is a subset of edges and vertices of H that is
isomorphic to a smaller graph G."

- "Induced subgraph isomorphism asks whether there is a subset of vertices of H whose deletion leaves a subgraph isomorphic
to a smaller graph G. For induced subgraph isomorphism, (1) all edges of G must be present in H, and (2) no non-edges of G can be present in H."

e.g. Clique happens to be an instance of both subgraph isomorphism problems, while
Hamiltonian cycle is only an example of vanilla subgraph isomorphism

</text>




<document>
<tag>isomorphism-invariants</tag>
<title>Isomorphism invariants and certificates</title>


<text>
A property associated to a graph is said to be an isomorphism invariant if it is the same for any two isomorphic graphs.

e.g.

- number of vertices
- number of edges
- degree sequences
- connectedness

- transposing rows and columns in the adjacency matrix

Two graphs are isomorphic if and only if there is a permutation matrix P such that <eqn>A_2 = P \times A_1 \times P^{-1}</eqn>
</text>

<text>
A certificate for isomorphism is a graph invariant i such that for any two graphs i(G1)=i(G2) if and only if G1 and G2 are isomorphic
</text>

<text>
IDEAS
</text>


<text>
CANONICAL ORDERING

A canonical numbering algorithm for graphs outputs a permutation N(G) of the vertices of the input graph so that two graphs are isomorphic if an only if the bijection defined by the permutation is an isomorphism. The vertex ordering produced by the canonical numbering algorithm is a canonical ordering of the vertices of G.

Given an ordering \tau of the vertices of a graph, S_{\tau}}(G) is the bit vector obtained by concatenating the rows of the adjacency matrix A_{\tau}(G). If we choose S_{\tau}}(G) to be the lexicographically smallest such bit vector, when S(G) defines a certificate for graphs and the corresponding vertex ordering is a canonical numbering of the vertices of the graph.
</text>

<text>
REFINEMENT TECHNIQUE
<cite>Corneil and Gotlieb 1970</cite>
<cite>Weisfeiler and Leman 1968</cite>
<cite>Weisfeiler 1976</cite>
The basis for most efficient heuristic and randomized graph isomorphism algorithms based on backtracking, e.g. nauty



Definitions:

- Coloring of a graph \sigma: Mapping from vertices to a set C (often integers)
- Trivial coloring: the same color to every vertex
- Color class C_i: the set of vertices with the same assigned color (coloring as a partition of vertices into color classes)
- Neighborhood N(v): adjacent vertices
- Degree vector: assigns each vertex a vector deg_{\sigma}(v) = ( |N(v) \intersect C_1|, .., |N(v) \intersect C_k| ).

- Refinement of a graph coloring = The new coloring R(\sigma) obtained by partitioning each color class with subsets with the same degree vector.
- A coloring is said to be stable if it has the same color classes as its refinement.
- For stable colorings, we define the color-class size vector s(\sigma) = ( |C_1|, .., |C_k| ) and the color-class adjacency matrix

  M(\sigma) = [ m_i,j ] = | N(x) \intersect C_j | where x \in C_j

- The stabilization of a coloring is the coloring that results from iterating the refinement process until a stable coloring \sigma^* is obtained.

- Given two colored graphs, a mapping V(G_1) \rightarrow V(G_2) is color-preserving if every color class of G_1 is mapped to a a single color class of G_2.


Facts:
\sigma_1 \sigma_2 colorings of graphs G_1 G_2

- If \phi is a color-preserving isomorphism between G_1 and G_2, \phi is a color-preserving mapping for the refinements R(\sigma_1) and R(\sigma_2).
- If \phi is a color-preserving isomorphism between G_1 and G_2, deg_{\sigma_1}(v) = deg_{\sigma_2}(\phi(v)) 
- If there is a color-preserving isomorphism between G_1 and G_2, s(\sigma_1^*)=s(\sigma_2^*) and M(\sigma_1^*)=M(\sigma_2^*)

- Let \tau_1 and \tau_2 be two trivial colorings of G_1 and G_2, respectively. Then, G_1 and G_2 are isomorphic if and only if there is a color-preserving isomorphism with respect to the colorings \tau_1^* and \tau_2^*
</text>

<text>
GENERALIZATION OF THE DEGREE SEQUENCE: PATH DEGREE SEQUENCE MATRIX or PATH LAYER MATRIX
ref. M. Randiic: "Design of molecules with desired properties". In M.A.Johnson and G.M. Maggiora (eds.) "Concepts and Applications of Molecular Similarity", Wiley, 1990, pp. 77-145
ref. A.A. Dobrynin and L.S. Melnikov: "Recent results in the theory of the path layer matrix". Graph Theory Notes of New York XLIII (2002) 48-56

\lambda(G) = [ \lambda_{i,j} ]

where \lambda_{i,j} is the number of paths of length j that start at vertex v_i of G.

Not a certificate for graph isomorphism, yet might still be useful
</text>

</document>



<document>
<tag>isomorphism-backtracking</tag>
<title>Backtracking algorithms for graph isomorphism</title>


<text>
SOLUTION: Backtracking

The basic algorithm backtracks through
all n! possible relabelings of the vertices of graph h with the names of vertices
of graph g, and then tests whether the graphs are identical. Of course, we can
prune the search of all permutations with a given prefix as soon as we detect any
mismatch between edges whose vertices are both in the prefix.

++ Labels and related constraints can be factored into any backtracking algorithm.


++ the real key to efficient isomorphism testing is to preprocess the vertices
into "equivalence classes," partitioning them into sets of vertices so that two
vertices in different sets cannot possibly be mistaken for each other. All vertices
in each equivalence class must share the same value of some invariant that is independent
of labeling. Possibilities include:

- Vertex degree - This simplest way to partition vertices is based on their degree-the number of edges incident on the vertex. Two vertices of different degrees cannot be identical. This simple partition can be a big win, but won't do much for regular (equal degree) graphs.

- Shortest path matrix - For each vertex v, the all-pairs shortest path matrix defines a multiset of n-1 distances representing
the distances between v and each of the other vertices. Any two identical vertices must define the exact same multiset of distances, so we can partition the vertices into equivalence classes defining identical distance multisets.

- Counting length-k paths - Taking the adjacency matrix of G and raising it to the kth power gives a matrix where Gk[i, j] counts the number of (nonsimple) paths from i to j. For each vertex and each k, this matrix defines a multiset of path-counts, which can be used for partitioning as with distances above. You could try all 1 le k le n or beyond, and use any single deviation as an
excuse to partition.

Using these invariants, you should be able to partition the vertices of most graphs into a large number of small equivalence classes. Finishing the job off with backtracking should then be short work. We assign each vertex the name of its equivalence class as a label, and treat it as a labeled matching problem. It is harder to detect isomorphisms between highly-symmetric graphs than it is with random graphs because of the reduced effectiveness of these equivalence-class partitioning heuristics.

</text>



<text>
Backtracking:

Node: Quadruple (G_1, \pi_1, G_2, \pi_2) where \pi_1 and \pi_2 are stable colorings of the graphs G_1 and G_2 for which a color-preserving isomorphism is suspected.

Root of the tree: (G_1, \pi_1^0, G_2, \pi_2^0) where \pi_1^0 and \pi_2^0 are stabilizations of the trivial colorings of the graphs G_1 and G_2

Child nodes: constructed by selecting a vertex in a non-singleton color class of \pi_1 (the pivot vertex), a vertex in the corresponding color class of \pi_2, and fixing them (making them correspond to singleton classes in the new colorings). Stabilization completes the generation of the child node. If the selected color class contains x vertices, x child nodes are generated.

- \rho stabilization of the coloring obtained from \pi by replacing C with two color classes {v} and C-{v}. Fixing v shatters C is every color class C' of \rho which is a subset of C is either a singleton or 1 &lt; |C'| &lt; |C|/2


e.g.
Combination of backtracking with refinement:

If for every non-leaf node of the backtracking tree, fixing the pivot shatters every non-singleton color class, the height of the backtracking tree is O(log n) and the running time of the algorithm is O(n^{log n}).

	G.Miller: On the n^{log n} isomorphism technique: A preliminary report. 10th ACM STOC, 1978, 51-58
	G.Miller: Graph isomorphism, general remarks, Journal of Computer and System Sciences, 1979, 128-142.

</text>


<text>
Practical algorithms for graph isomorphism:
- <cite>Corneil and Gotlieb 1970</cite>: Refinement technique
- <cite>McKay 1981</cite>: nauty heuristics...
- <cite>Schmidt and Druffel 1976</cite>
- <cite>Ullman 1976</cite>
</text>




<text>
While they seem to perform well on random graphs, a major drawback of these algorithms is their exponential time performance in the worst case.
</text>


<text>
Best known algorithm: <q>Canonical labeling of graphs</q> <cite>Babai and Luks 1983</cite>

subexponential time algorithm for a graph with n vertices.

<eqn>2^{O(\sqrt{n \log n})}</eqn> for graphs with n vertices.
</text>

</document>




<document>
<tag>isomorphism-polynomial</tag>
<title>Polynomial-time graph isomorphism</title>

<text>
Isomorphism for many special classes of graphs can be solved in polynomial time, and in practice graph isomorphism can often be solved efficiently:
</text>


<text>
++ Faster algorithms exist for trees and planar graphs. 

- Trees (e.g. NLP, parsing):  Begin with the leaves of both trees and work inward toward the center. Each vertex in one tree is assigned a label representing the set of vertices in the second tree that might possibly be isomorphic to it, based on the constraints of labels and vertex degrees. For example, all the leaves in tree T1 are initially potentially equivalent to all
leaves of T2. Now, working inward, we can partition the vertices adjacent to leaves in T1 into classes based on how many leaves and non-leaves they are adjacent to. By carefully keeping track of the labels of the subtrees, we can make sure that we have the same distribution of labeled subtrees for T1 and T2. Any mismatch means T1 != T2, while completing the process partitions the
vertices into equivalence classes defining all isomorphisms. A linear-time tree isomorphism algorithm
for both labeled and unlabeled trees is presented in [AHU74].

</text>

<list>

<item>
 Trees 
 <cite>Kelly 1957</cite>, described in <cite>Aho et al. 1974</cite>
</item>

<item>
 Planar graphs 
 <cite>Hopcroft and Wong 1974</cite> 
 ++ M. Fontet: Linear algorithms for testing isomorphism of planar graphs, in Proceedings of the 3rd Coll. Automata, Languages, and Programming (S. Michaelson and R. Milner, eds.), Edinburgh University Press, 1976
</item>

<item>Maximal outerplanar graphs <cite>Beyer et al. 1979</cite></item>

<item>Interval graphs <cite>Lueker and Booth 1979</cite></item>

<item>
 Circular graphs 
 ++ W. Hsu: O(mn) algorithms for the recognition and isomorphism problem on circular graphs. SIAM Journal of Computing, 24:411-439, 1995
</item>

<item>Permutation graphs <cite>Colbourn 1981</cite></item>

<item>Trivalent graphs <cite>Galil et al. 1987</cite></item>


<item>Bounded-parameter graphs: 
- Graphs of bounded genus <cite>Miller 1980</cite> <cite>Filotti and Mayer 1980</cite> 
++ M. Grohe: Isomorphism testing for embeddable graphs through definability. 32nd ACM STOC, 2000, 229-236

- graphs of bounded degree <cite>Luks 1982</cite>

- graphs with bounded eigenvalue multiplicity <cite>Babai et al. 1982</cite>

- graphs with bounded tree width, a.k.a. partial k-trees
++ H.L Bodlaender: Polynomial algorithms for chromatic index and graph isomorphism on partial k-trees. J. Algorithms, 11:631-643, 1990
<cite>Bodlaender 1990</cite>

- k-Contractible graphs (a generalization of bounded degree and bounded genus) <cite>Miller 1983a</cite> <cite>Miller 1983b</cite> 

- Color-preserving isomorphism of colored graphs with bounded color multiplicity (i.e., at most k vertices have the same color for a fixed k)
<cite>Luks 1986</cite>
</item>


</list>

</document>


<document>
<tag>isomorphism-software</tag>
<title>Graph isomorphism software</title>

<text>
SOFTWARE: ell now that you've gone and starting learning about some computational complexity in relationship to graph isomorphism, it's probably a good time to stop and look at actual practical algorithms for graph isomorphism.  The king of the hill here, as far as I know, is the program nauty (No AUTomorphism, Yes?) by Brendan D. McKay.  http://cs.anu.edu.au/people/bdm/nauty/ <cite>McKay 1981</cite>


"The best known isomorphism testing program is nauty (No
AUTomorphisms, Yes?) - set of very efficient C language procedures for determining
the automorphism group of a vertex-colored graph. Nauty is also able to
produce a canonically-labeled isomorph of the graph, to assist in isomorphism testing.
</text>

<text>
Implementation of Weisfemer-Leman algorithm (a generalization of the refinement technique described above)

ref.
L. Babel, I.V. Chuvaeva, M. Klin, D.V. Pasechnik
Algrbraic Combinatorics in Mathematical Chemistry. Methods and Algorithms II. Program Implementation of the Weisfeiler-Leman algorithm
Technische Universität München, TUM-M9701, 1997
</text>

<text>
The VFLib graph-matching library contains implementations for several different
algorithms for both graph and subgraph isomorphism testing. This library
has been widely used and very carefully benchmarked [FSV01]. It is available at
http://amalfi.dis.unina.it/graph/.

GraphGrep [GS02] (http://www.cs.nyu.edu/shasha/papers/graphgrep/) is a representative
data mining tool for querying large databases of graphs.

Valiente [Val02] has made available the implementations of graph/subgraph
isomorphism algorithms for both trees and graphs in his book [Val02]. These C++
implementations run on top of LEDA (see Section 19.1.1 (page 658)), and are
available at http://www.lsi.upc.edu/¡«valiente/algorithm/.

</text>


</document>


<document>
<tag>isomorphism-notes</tag>
<title>Bibliographic notes</title>

<text>
REFERENCES @ SKIENA
Graph isomorphism is an important problem in complexity theory. Monographs
on isomorphism detection include [Hof82, KST93]. Valiente [Val02] focuses on algorithms
for tree and subgraph isomorphism. See [FSV01] for performance comparisons between different graph
and subgraph isomorphism algorithms.

Polynomial-time algorithms are known for planar graph isomorphism [HW74] and for
graphs where the maximum vertex degree is bounded by a constant [Luk80]. The all-pairs
shortest path heuristic is due to [SD76], although there exist nonisomorphic graphs that
realize the exact same set of distances [BH90]. 

A problem is said to be isomorphism-complete if it is provably as hard as isomorphism.
Testing the isomorphism of bipartite graphs is isomorphism-complete, since any graph
can be made bipartite by replacing each edge by two edges connected with a new vertex.
Clearly, the original graphs are isomorphic if and only if the transformed graphs are.
</text>

<text>
Gross-Yellen: Chapter 2.2
Mark Goldberg: "The graph isomorphism problem"


[AHU] A. V. Aho, J. E. Hopcroft, and J.D. Ullman, The Design and Analysis 
of Computer Algorithms, Addison-Wesley, 1974.

[Ba80] L. Babai, P. Erd\"os, and S. M. Selkov, Random graph isomorphism,
{\sl SIAM J. of Computing} (1980), Vol. 9,  628--635.

[Ba82] L. Babai, D. Yu. Grigoryev, and D. M. Mount, Isomorphism of graphs 
with bounded multiplicity, 
{\sl Proceedings 14th Ann. ACM Symp. Theory of Computing} (1982), 310--324.

[Ba83] L. Babai and E. M. Luks, Canoncal labeling of graphs,
{\sl Proceedings 15th Ann. ACM Symp. Theory of Computing} (1983),  171--183.

[Bo78] K. S. Booth, Isomorphism testing for graphs, semigroups and finite
automata are polynomially equivalent, {\sl SIAM J. Computing}, 7, (1978),
273--279.

[Co78] M. J. Colbourn and C. J. Colbourn, Graph isomorphism and self-complementary graphs, {\sl SIGACT News}, 10, (1978), 25--29.

[Co81] M. J. Colbourn and K. S. Booth, Linear time automorphism algorithm 
for trees, interval graphs, and planar graphs, {\sl SIAM J. Computing}, 10,
(1981), 203--225.



[Co84] D. Corneil and M. Goldberg, A Non-Factorial Algorithm for 
Canonical Numbering of a Graph,
{\sl J. Algorithms} Vol. 5, (1984),  345--362.

[De77] N. Deo, J. M. Davis, and R. E. Lord, A new algorithm for 
digraph isomorphism, {\sl BIT}, (17), (1977), 16--30.

[Fi80] I. S. Filotti and J. N. Mayer, A polynomial algorithm for determining 
the isomorphism of graphs of fixed genus, {\sl Proceedings 12th Ann. ACM Symp. 
Theory of Computing}, 17, (1980), 236--243,

[F\"u83] M. F\"urer, W. Schnyder, and E. Specker,
Normal forms for trivalent graphs and graphs of bounded valency,
{\sl Proceedings 15th Ann. ACM Symp. Theory of Computing}, (1983),
161--170.

[Fu80] M. Furst, J. Hopcroft, and E. Luks,
A subexponential algorithm for trivalent graph isomorphism, 
{\sl Proceedings 11th Southesatern Conference on Combinatorics, Graph
Theory, and Computing}, (1980);in Congressum Numerantium, 33,
36--41.

[Fu80] M. Furst, J. Hopcroft, and E. Luks,
Polynomial time algorithms for permutation groups, 
{\sl Proceedings 21th IEEE Symp. on Foundations Computer Science}, (1980),
36--41.

[Ga87] Z. Galil, C. M. Hoffman, E. M. Luks, C. P. Schnorr, and 
A. Weber], An $O(n^3 \log n)$ deterministic and $O(n^3)$ probabilistic 
isomorphism test for trivalent graphs, {\sl J. ACM}, 34, (1987), 513--531.

[Go83] M. Goldberg, A Non-Factorial Algorithm for the Graph 
Isomorphism Problem,
{\sl Discrete Applied Mathematics} Vol. 6, (1983),  229--236.

[Ha82] F. Harary, M. Plantholt, and R. Statman, The graph
isomorphism problem is polynomially equivalent to the legitimate
deck problem for regular graphs, {\sl Carib\-bean J. Math.}
1(1) (1982),  15--23.}

[Ho74] J. E. Hopcroft and C. K. Wong, Linear Time algorithms for 
isomorphism of planar graphs, {\sl Proceedings 6th Ann. ACM Symp. 
Theory of Computing}, (1974), 172--184.

[Ho82] C. M. Hoffman, Group-Theoretic Algorithms and Graph Isomorphism,
{\sl Lectures Notes in Computer Science}, 136, (1982), Springer.

[JvLe99] J. van Leeuwen, in {\sl Handbook of Theoretical Computer Science} 
Chapter 10, Graph Algorithms, (1994), Elsevier Scienceu 525--631.

[Kl02] A. Klivans and D. van Melkebeek,
Graph Nonisomorphism has Subexponential Size Proof Unless the Polynomial-Time 
Hierarchy Collapses, {\sl SIAM J. Computing}, 31, (2002), 1501--1526.

[K\"o93] J. K\"obler, U. Sch\"oning, and J. Tor\'an, {\sl
The Graph Isomorphism Problem: Its Structural Complexity},
Birkh\"auser, 1993.}

[Kr94] D. Kratsch and L. A. Hemaspaandra, On the complexity
of graph reconstruction, {\sl Math. Systems Theory}
27(3) (1994), 257--273.}

[Kr02] I. Krasikov, A. Lev, and B.D. Thatte, Upper bounds
on the automorphism group of a graph, {\sl Discrete Math.}
256 (2002), 489--493.

[Lu82] E. M. Luks, {Isomorphism of graphs of bounded valence can be tested
in polynomial time}, {\sl J. Comput. System Sci.}, 25, (1982), 42--65.

[Lu81] A. Lubiw, Some NP-complete problems similar to graph isomorphism,
{\sl SIAM J. Computing} Vol. 10, (1981),  11--24.

[Ma82] A. Mansfield, The relationship between the
computational complexities of the legitimate deck and isomorphism
problems, {\sl Quart. J. Math. Oxford (2)} 33 (1982), 345--347.

[Ma79] R. Mathon, ``A note on the graph isomorphism counting problem'',
{\sl Information Processing Letters}, Vol. 8, No.3 (1979), 131--132.

[Mc81] B. D. McKay, Practical Graph Isomorphism, {\sl Congressus Numerantium},
30, (1981), 45--87.

[Mi80], G. Miller, Isomorphism testing for graphs of bounded genus,
{\sl Proceedings 12th Ann. ACM Symp. Theory of Computing},
17, (1980), 225--235.

<cite>Weisfeiler and Leman 1968</cite>
[We68], B. Weisfeiler and A.A. Leman, Reduction of a graph to a canonical
form and an algebra arizing during this reduction,
{\sl Nauchno-Technicheskaya Informatsia}, 9, Ser. 2, (1968), 12--16.

<cite>Weisfeiler 1976</cite>
[We79], B. Weisfeiler, (ed.) On construction and identifacation of graphs,
{\sl Lecture Notes in Mathematics}, 558, Springer, Berlin, (1976).


</text>

<text>
Excellent online survey by Dave Bacon 
(former quantum computing theory professor at the University of Washington, now software engineer at Google):
"Reading List: Graph Isomorphism"
2010

++ http://dabacon.org/pontiff/?p=4148
</text>

</document>

</document>
